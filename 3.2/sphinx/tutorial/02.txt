.. highlight:: python
   :linenothreshold: 1

Tutorial - part 2/2
===================

.. note ::

  Be sure to complete :doc:`part 1 <./01>` of the tutorial first.
  Some ideas previously explained there are not repeated here.

Invoking other systems
----------------------

To summarise it, in the previous part we set up a working Zato cluster, deployed a service and created
a REST API channel through which the service was invoked.

.. image:: /gfx/tutorial/service-complete.png

In this part we will make the service actually obtain data from remote systems and process it in accordance
with its business requirements. Initial chapters of this part of the tutorial will mostly use the Dashboard
to configure external connections and we will return to Python afterwards.

To invoke other systems, applications and APIs, Zato services uses outgoing connections which is the
concept we will cover now.

Outgoing connections
--------------------

Outgoing connections are the natural counterpart to channels. Whereas channels allow one to make
Zato services become available to external API clients, with outgoing connections (outconns for short)
it is Zato services that invoke endpoints of external systems.

All outconns are invoked using attributes from **self.out**, e.g. self.out.rest, self.out.amqp, self.out.sap and so on,
maintaining a connection pool internally when needed so that services can just focus on the invocation part.

Outgoing connections, like channels or other Zato elements, let you insulate the business logic of services
from their configuration. As we will see later, a service only refers to abstract names like "CRM" when it wants
to access some external resource, without a need for it to know when the CRM actually is, under what address and secured
with what credentials.

Separating logic from configuration lets you deploy the same unchanged code to multiple environments. It also means
that it is easy migrate to new or modified environments. For instance, if today your service connects to a REST API
with a Basic Auth security definition but tomorrow the API will be secured with TLS private keys, it will be only
a matter of an update to configuration, but the service will continue to work uninterrupted, without any downtime.

Throughout the tutorial we mostly use the Dashboard to manage configuration but it can be exported to YAML and imported
in other environments too, we will tell of it later.

In addition to outconns, it is also possible to install libraries from `PyPI <https://pypi.org>`_ and invoke remote
systems using client libraries for connection types other than what Zato has built-in.

For the purposes of the tutorial, all the REST and AMQP endpoints are already prepared on zato.io so that you do not
need to set up anything and we can start by creating the outconns now.

REST outgoing connections
-------------------------

In Dashboard at http://localhost:8183, go to Connections -> Outgoing -> REST and click  Create a new REST outgoing connection.

.. image:: /gfx/tutorial/dashboard-outconn-rest-menu.png

A form will pop up, fill it out per the table below. Note the default HEAD ping method, we are going to make use of
it in the section.

=========== ==============================
Header      Value
=========== ==============================
Name        CRM
Host        \http://zato.io:9193
URL path    /tutorial/get-customer
Data format JSON
Security    No security
=========== ==============================

We need a REST outgoing connection to the Payments system too, as in the following table. Most of the details
are the same but note that the URL path contains a string pattern - we will talk about it in a moment.

=========== ==================================
Header      Value
=========== ==================================
Name        Payments
Host        \http://zato.io:9193
URL path    /tutorial/get-balance/{account_id}
Data format JSON
Security    No security
=========== ==================================

Pinging REST outgoing connections
---------------------------------

Having created REST outconns, we can check if they have connectivity to the systems they point to by pinging them - there is
Ping link for each outconn.

.. image:: /gfx/tutorial/dashboard-outconn-rest-ping-button.png

Click it and confirm that the response is similar to the one below - as long as it is in green, the connection works fine.

.. image:: /gfx/tutorial/dashboard-outconn-rest-ping-result.png

The connection is pinged not from your localhost but from one of the servers in your cluster - in this way you can confirm
that it truly is your servers, rather than your local connection, that has access to a remote endpoint.

AMQP outgoing connections
-------------------------

AMQP connections are created similarly to the REST ones except that instead of going directly to outgoing connections,
we first visit Connections -> Definitions -> AMQP in the Dashboard.

Connection definitions are reusable configuration objects that are used if a given technology or protocol can be used
in both channels and outgoing connections which is the case with AMQP. The tutorial only sends messages to AMQP
but in another project you may have both AMQP channels and outconns pointing to the same broker.

Having a single definition with credentials for both types makes it convenient
to update the common parts of the configuration in one place only, i.e. after you change a username or host in
an AMQP definition, all channels and outgoing connections using this definition will auto-reconfigure and reconnect as needed.

Thus, go to Connections -> Definitions -> AMQP and create a new definition as in this table.

============ ==========================
Header       Value
============ ==========================
Name         Fraud Detection Definition
Host         zato.io
Port         34034
Virtual host /tutorial
Username     api
============ ==========================

This created a new AMQP connection definition and we need to set the user's password. Click Change password and enter
**wTGL6pQ9KxH2U** - note that the password changes frequently and it may be different if you visit the tutorial in some time.

At this point, we have a definition but by itself, it will not connect to an AMQP broker, it is only channels or outconns
that connect using configuration and credentials from their definitions.

Hence, create a new AMQP outconn at Connections -> Outgoing -> AMQP. Except for the two specific values below
you can leave the rest unchanged with blank or default values.

========== ==========================
Header     Value
========== ==========================
Name       Fraud Detection Connection
Definition Fraud Detection Definition
========== ==========================

Pinging AMQP with publications
------------------------------

We can ping a remote AMQP broker by publishing a message to it. While in Connections -> Outgoing -> AMQP
and click Publish.

.. image:: /gfx/tutorial/dashboard-outconn-amqp-publish-button.png

Now, send a test message using the configuration below.

============ ==========================
Header       Value
============ ==========================
Data         (Any)
Exchange     /tutorial
Routing key  api
============ ==========================

There will be a response on a green background confirming that the message was published successfully.

.. image:: /gfx/tutorial/dashboard-outconn-amqp-publish-form.png

All the outgoing connections are created so we can now shift our attention back to the Python service.

Back to the service
-------------------

The logic of our service shall be:

* Accept user_name on input
* Invoke CRM to get basic user data, including account_number and user_type
* Invoke Payments to get account details by account_number
* If user_type matches configuration, notify Fraud detection about it all

In a bigger integration project, an individual user would have more than one bank account
but here we keep it simple and assume that each user has one bank account.

Here is the full Python implementation of the logic above. You can also find it on GitHub ZXCZXCZXC.

.. code-block:: python
  :linenos:

    # -*- coding: utf-8 -*-
    # zato: ide-deploy=True

    # Zato
    from zato.server.service import Service

    class GetUserDetails(Service):
        """ Returns details of a user by the person's ID.
        """
        name = 'api.user.get-details'

        def handle(self):

            # For later use
            user_name = self.request.payload['user_name']

            # Get data from CRM ..
            crm_data = self.invoke_crm(user_name)

            # .. extract the CRM information we are interested in ..
            user_type = crm_response['UserType']
            account_no = crm_response['AccountNumber']

            # .. get data from Payments ..
            payments_data = self.invoke_payments(user_name, account_no)

            # .. extract the CRM data we are interested in ..
            account_balance = payments_data['ACC_BALANCE']

            # .. optionally, notify the fraud detection system ..
            if self.should_notify_fraud_detection(user_type):
                self.notify_fraud_detection(user_name, account_no)

            # .. now, produce the response for our caller.
            self.response.payload = {
              'user_name': user_name,
              'user_type': user_type,
              'account_no': account_no,
              'account_balance': account_no,
          }

    # ##############################################################################

        def invoke_crm(self, user_name):

            # Obtain a connection to CRM ..
            conn = self.out.rest['CRM'].conn

            # .. produce a request for CRM ..
            request = {
                'UserName': user_name,
            }

            # .. invoke the CRM ..
            crm_response = conn.get(self.cid, request)

            # .. return data received from CRM.
            return crm_response.data

    # # ##############################################################################

        def invoke_payments(self, user_name, account_no):

            # Log what we are about to do
            self.logger.info('Invoking Payments; %s %s', user_name, account_no)

            # Obtain a connection to Payments ..
            conn = self.out.rest['Payments'].conn

            # .. prepare a request for Payments ..
            request = {
                'ACC_NUM': account_no
            }

            # .. invoke Payments ..
            response = crm_conn.post(self.cid, user_name=user_name)

            # .. return data received from Payments.
            return response.data

    # ##############################################################################

        def notify_fraud_detection(self, account_no):

            # Data to send to the Fraud detection system
            data = 'Account {} was accessed on {}'.format(
                account_no, self.time.utcnow())

            # AMQP configuration
            outconn = 'Fraud Detection Connection'
            exchange = '/tutorial'
            routing_key = 'api'

            # Send the message to an AMQP broker
            self.out.amqp.send(data, outconn, exchange, routing_key)

    # ##############################################################################

        def should_notify_fraud_detection(self, user_type):
            return self.kvdb.get('tutorial.notify.fraud.detection.{}'.format(user_type))

    # ##############################################################################


Runtime configuration
---------------------

API testing
-----------

Enmasse automation
------------------

More features
-------------

Getting support
---------------
