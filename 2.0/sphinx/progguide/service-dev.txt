.. warning::
   This document is for a version of Zato that is no longer supported. The newest one is `here </docs/>`_.


.. highlight:: python
   :linenothreshold: 0

Developing services
===================

From a programmer's point of view, a service is a Python class that subclasses
`zato.server.Service <https://github.com/zatosource/zato/blob/support/2.0/code/zato-server/src/zato/server/service/__init__.py>`_
and implements a handle(self) method.

Below is the simplest possible Zato service meant to illustrate the point of how
little coding is needed to write services. Granted, it doesn't do much useful,
but still can be :doc:`hot-deployed <../admin/guide/installing-services>` 
and while it's not possible to
:doc:`invoke <./invoking-services>`
it through
:doc:`channels <./channels>`,
it's still a valid service.


::

   from zato.server.service import Service
   
   class MyService(Service):
       def handle(self):
           pass
           
.. note:: Looking for a set of scaled-down practical examples to study?

   :doc:`Click here <./examples/index>` to visit a separate chapter with sample services.

           
.. _progguide-conventions:
           
Programming conventions
-----------------------

* Services are developed in `Python 2.7.x <http://docs.python.org/2.7/>`_. No
  other Python versions can be used although adding support for Python 3.x is planned.

* You can't use the name 'zato', case-insensitively, anywhere. Any such names
  are reserved and can't be used. For instance, 'zato.sample', 'my:zato:data',
  'X-ZATO-SERVER' and 'ZatoReceiver' are all invalid.
  
  This applies to any Zato object you will use - services, connection names,
  channel names, any other.
  
* All input and output is always in UTF-8. Zato doesn't use nor support any other 
  encoding. Each request and response must always be in UTF-8. Being a subset
  of UTF-8, ASCII will also be accepted but you're advised to always use UTF-8 anyway.
  Any other encodings, such as ISO-8859-1 or EBCDIC, are invalid.

* You are strongly encouraged to use the following header in each source code
  file you will keep services in. In fact, if you stumble upon any issues
  and need support you will be first asked that this header be added before any
  other advice can be given. Don't forget to set your code editor to write out
  files in UTF-8 too.
  
  This serves a couple of purposes:
  
  * Makes sure you actually use UTF-8 in your code
  * Lets you get prepared for Python 3.x
  * Ensures you use the same Python features :doc:`Zato's own services </public-api/intro>` use

  ::  
  
    # -*- coding: utf-8 -*-
  
    from __future__ import absolute_import, division, print_function, unicode_literals
    
* Each service invocation creates a new instance of the class the service is 
  represented as.
    
* Don't keep any state around if you want to use the :doc:`hot-deployment <../admin/guide/installing-services>` feature.
  Don't assign any values to classes the services are implemented in. Don't modify
  any module-global data. Use :doc:`Redis <../architecture/redis>` if you need to store data between
  invocations of a service. Otherwise it will still be possible to deploy a service
  but not without restarting a server.
  
* Don't start your own threads. Given Zato's architecture, there shouldn't really
  be any need for threads but if your use-case calls for it, 
  `please let the project know more <https://zato.io/support>`_ about why you need threads.
    
What a service can do
---------------------

Typically, a service will receive some input and produce an output. Both steps
are optional but usually at least one of them will be performed.

You can use 
:doc:`Simple IO (SIO)<./sio>`,
:doc:`JSON <./json>`,
:doc:`XML <./xml>`
or 
:doc:`any other data type <./other-formats>`
in your services.

Depending on the choices you make, it will be usually possible to make the very
same service, with no changes to the code, available across multiple 
:doc:`channels <./channels>`
- AMQP, JMS WebSphere MQ, Plain HTTP, SOAP and ZeroMQ

You can store data in 
Redis,
SQL databases
and specify your services be
periodically invoked through the scheduler.

A service can
:doc:`invoke other services <./invoking-services>`
as well as access resources outside a Zato environment.
The latter ones include
:doc:`AMQP <./outconn/amqp>`,
:doc:`JMS WebSphere MQ <./outconn/jms-wmq>`,
:doc:`Plain HTTP <./outconn/http>`,
:doc:`SOAP <./outconn/http>`,
:doc:`ZeroMQ <./outconn/zmq>`
and 
:doc:`FTP <./outconn/ftp>`.


Service API
-----------

This chapter will introduce the service API - a set of 
:ref:`attributes <progguide-write-service-attributes>`
and
:ref:`methods <progguide-write-service-methods>`
a service can make use of during processing of the messages.

Save the following code in service_api.py and :doc:`hot-deploy <../admin/guide/installing-services>` it - this will be
the service that will be modified throughout the rest of the text.

::

   from zato.server.service import Service
   
   class MyService(Service):
       def handle(self):
           pass

.. _progguide-write-service-attributes:

Service attributes
~~~~~~~~~~~~~~~~~~

broker_client
`````````````

Services can publish messages on a :doc:`Redis </architecture/redis>` broker. 
How to use a broker client is explained in a 
:ref:`separate section <progguide-write-service-broker-client>`.

.. _progguide-write-service-channel:

channel
```````

Type of the channel (not its name) a service has been invoked through. 
Can be one of:

* 'amqp'
* 'audit'
* 'fanout-call'
* 'fanout-on-final'
* 'fanout-on-target'
* 'internal-check'
* 'http-soap'
* 'invoke'
* 'invoke-async'
* 'invoke-async-callback'
* 'jms-wmq'
* 'notifier-run'
* 'notifier-target'
* 'scheduler'
* 'startup-service'
* 'worker'
* 'zmq'

The constants are defined in the 
`zato.common.CHANNEL <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
class.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('channel:[{}]'.format(self.channel))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - channel:[invoke]
  

.. _progguide-write-service-cid:

cid
```

A correlation ID (CID) of this request. Each request is assigned a CID
which is 128 bits of random data, encoded as a string.

The string is prefixed with the letter 'K' to ensure that it always start with a character. There
is nothing special about the letter 'K', it is simply a character chosen as a prefix.
Don't assume the prefix 
will always be 'K', future Zato versions may make it configurable or change it
without prior notice.

Note that when 
:ref:`publishing <progguide-write-service-broker-client-publish>`
a 
`SERVICE.PUBLISH.value <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/broker_message.py>`_
message to more than one server, each server worker will receive a request
with the same CID.

CID has always 28 characters.

.. warning ::

  You must not use CIDs for any cryptographical purposes. There is no guarantee
  that a CID will be suitable for any particular crypto operation. CIDs should
  only be used to tell one request from another. Use
  `UUID4 <http://docs.python.org/2.7/library/uuid.html>`_ or a similar data
  type if you need truly random data.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('cid:[{}]'.format(self.cid))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - cid:[K280592090634247650299684980809341216327]

.. _progguide-write-service-data_format:
  
data_format
```````````

Each channel can optionally define that the data flowing in will be in
a particular data format. It can be one of:

* None
* 'json'
* 'xml'

The constants are defined in the 
`zato.common.DATA_FORMAT <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
class.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('data_format:[{}]'.format(self.data_format))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service --data-format json
  
::

  INFO - data_format:[json]

.. _progguide-write-service-environ:
  
environ
```````

A dictionary of user-specific data that can be used for passing information
between :doc:`service hooks <./service-hooks>`. The service can store information in a
hook method and consult it in another one using the environ dictionary.

Zato will never use environ for its own purposes.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def before_handle(self):
          self.environ['seen_before_invoke'] = True
      
      def handle(self):
          self.environ['seen_handle'] = True
          
      def after_handle(self):
          for name in('seen_before_invoke', 'seen_handle'):
              self.logger.info('{}:[{}]'.format(name, self.environ[name]))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - seen_before_invoke:[True]
  INFO - seen_handle:[True]


.. _progguide-write-service-handle_return_time:

handle_return_time
``````````````````

A `datetime.datetime <http://docs.python.org/2.7/library/datetime.html#datetime-objects>`_
objects representing the time a service's :ref:`handle <progguide-write-service-handle>` method returned at.
Always in UTC.

Note that it will be available as a non-None value only in the 
:ref:`finalize_handle <progguide-write-service-finalize_handle>` service hook.

:ref:`invocation_time <progguide-write-service-invocation_time>` and
handle_return_time are used to compute the values of 
:ref:`processing_time <progguide-write-service-processing_time>`
and
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

.. _progguide-write-service-impl_name:

impl_name
`````````

Name of the module and class implementing a given service. Contrast
with :ref:`name <progguide-write-service-name>`.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('impl_name:[{}]'.format(self.impl_name))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - impl_name:[service_api.MyService]

.. _progguide-write-service-invocation_time:

invocation_time
```````````````

A `datetime.datetime <http://docs.python.org/2.7/library/datetime.html#datetime-objects>`_
object representing the time a service has been invoked at. Always in UTC.

invocation_time and
:ref:`handle_return_time <progguide-write-service-handle_return_time>` are used to compute the values of 
:ref:`processing_time <progguide-write-service-processing_time>`
and
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('invocation_time:[{}]'.format(self.invocation_time))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - invocation_time:[2013-02-17 17:47:01.045913]

.. _progguide-write-service-job_type:

job_type
````````

If a service has been :doc:`invoked through a scheduler's job <./scheduler>`, type of the job
it was. None if the scheduler wasn't used. Can be one of:

* None
* 'one_time'
* 'interval_based'
* 'cron_style'

The constants are defined in the 
`zato.common.SCHEDULER_JOB_TYPE class <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('job_type:[{}]'.format(self.job_type))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - job_type:[None]
  
kvdb
````

An object which lets one use :doc:`Redis, Zato's key/value database (KVDB) <../architecture/redis>`.
The underlying `redis-py connection <https://github.com/andymccurdy/redis-py>`_
is available as self.kvdb.conn.

::

  from zato.common import KVDB
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          key = '{}{}'.format(KVDB.SERVICE_USAGE, self.name)
          usage = self.kvdb.conn.get(key)
          self.logger.info('{} was invoked {} time(s)'.format(self.name, usage))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - service-api.my-service was invoked 16 time(s)

.. _progguide-write-service-logger:

logger
``````

A logger, instance of
`zato.server.log.ZatoLogger <https://github.com/zatosource/zato/blob/support/2.0/code/zato-server/src/zato/server/log.py>`_, 
used for writing messages out to server logs.
This is a thin wrapper around `Python's logging.Logger <http://docs.python.org/2.7/library/logging.html>`_
which lets one use a 'cid' argument in addition to what is ordinarily available
when using a standard logger. This allows to use a 'cid' parameter in server logs.

Observe how the log output contains the CID now:

::

  %(asctime)s - %(cid)s - %(message)s

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('Hello!', cid=self.cid)

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  2013-02-17 19:48:33,585 - K300817487686039172650072756834592513215 - Hello!
  

.. _progguide-write-service-name:
  
name
````

Name of the service under which it will be possible to :ref:`invoke it <progguide-write-service-invoke>` and point to it
in the web admin. Contrast with :ref:`impl_name <progguide-write-service-impl_name>`.

Visit :ref:`get_name <progguide-write-service-get_name>` for a way to override it.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('name:[{}]'.format(self.name))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - name:[service-api.my-service]
  
odb
```

An object through which one can access 
:doc:`Zato's Operational Database (ODB) </architecture/sql-odb>`.
An `SQLAlchemy <http://sqlalchemy.org>`_ session object,
used to issue queries, is available as .session() - note that it always needs to be 
closed manually hence the use of the
`closing <http://docs.python.org/2.7/library/contextlib.html#contextlib.closing>`_
context manager in the example below.

::

  # stdlib
  from contextlib import closing
  
  # Zato 
  from zato.common.odb.model import Cluster
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          with closing(self.odb.session()) as session:
              for item in session.query(Cluster).all():
                  self.logger.info(item.name)

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - quickstart-351218
  INFO - quickstart-807391
  INFO - quickstart-984115
  INFO - quickstart-136892
  INFO - quickstart-758758
  
outgoing
````````

Lets one invoke external
:doc:`FTP <./outconn/ftp>`,
:doc:`AMQP <./outconn/amqp>`,
:doc:`ZeroMQ <./outconn/zmq>`,
:doc:`JMS WebSphere MQ <./outconn/jms-wmq>`,
:doc:`SQL <./outconn/sql>`,
:doc:`Plain HTTP <./outconn/http>`
and 
:doc:`SOAP <./outconn/http>`
resources. Consult the documentation of each one for more information.

.. _progguide-write-service-processing_time:

processing_time
```````````````

Time it took for the service to complete its operation, in milliseconds. Compare with 
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

Note that it will be available as a non-None value only in the 
:ref:`finalize_handle <progguide-write-service-finalize_handle>` service hook.

processing_time will be equal to 0 if it took less than 1 ms.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          pass
      
      def finalize_handle(self):
          self.logger.info('Processing took {} ms'.format(self.processing_time))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - Processing took 0 ms
  
.. _progguide-write-service-processing_time_raw:
  
processing_time_raw
```````````````````
A `datetime.timedelta <http://docs.python.org/2.7/library/datetime.html#timedelta-objects>`_
object representing the time spent in a service, with microseconds precision. 
Compare with :ref:`processing_time <progguide-write-service-processing_time>`.

Note that it will be available as a non-None value only in the 
:ref:`finalize_handle <progguide-write-service-finalize_handle>` service hook.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          pass
      
      def finalize_handle(self):
          self.logger.info('Processing took {}'.format(self.processing_time_raw))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - Processing took 0:00:00.000077
  
request
```````

:ref:`request <progguide-req-resp-req>`
and
:ref:`response <progguide-req-resp-resp>`
attributes are discussed in 
:doc:`a separate chapter <./request-response>`.

response
````````
:ref:`request <progguide-req-resp-req>`
and
:ref:`response <progguide-req-resp-resp>`
attributes are discussed in 
:doc:`a separate chapter <./request-response>`.

slow_threshold
``````````````
Response time threshold, in milliseconds, after exceeding of which a service
invocation will be considered :doc:`a slow one <../web-admin/service-details/slow-responses>`. 
Top 100 slow invocations
of a service are stored for a later inspection.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My threshold is {} ms'.format(self.slow_threshold))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - My threshold is 99999 ms
  
usage
`````
How many times the service has run, including the current invocation.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My usage is {}'.format(self.usage))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - My usage is 38

.. _progguide-write-service-time:

time
````

Accesses utilities for working with date/time. Documented in :doc:`their own chapter <./datetime>`.

.. _progguide-write-service-wsgi_environ:
  
wsgi_environ
````````````
Zato's HTTP server is a 
`WSGI <https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface>`_
one. If a service has been invoked through HTTP, wsgi_environ will be a dictionary of WSGI data.

The dictionary under zato.http.response.headers must not be used directly to define
what HTTP response headers a service will return. Use 
:ref:`response.headers <progguide-req-resp-resp>` instead.

Note that the example below assumes the service has been mounted at /service-api.my-service
through a plain HTTP channel,
otherwise, had :doc:`zato service invoke <../admin/cli/service-invoke>` been used
as an access method,  wsgi_environ would've been empty.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          for key, name in sorted(self.wsgi_environ.items()):
              self.logger.info('{}:{}'.format(key, name))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - HTTP_ACCEPT:*/*
  INFO - HTTP_HOST:localhost:17010
  INFO - HTTP_USER_AGENT:curl/7.22.0 (x86_64-pc-linux-gnu)
  INFO - PATH_INFO:/service-api.my-service
  INFO - QUERY_STRING:
  INFO - RAW_URI:/service-api.my-service
  INFO - REMOTE_ADDR:127.0.0.1
  INFO - REMOTE_PORT:34707
  INFO - REQUEST_METHOD:GET
  INFO - SCRIPT_NAME:
  INFO - SERVER_NAME:localhost
  INFO - SERVER_PORT:17010
  INFO - SERVER_PROTOCOL:HTTP/1.1
  INFO - SERVER_SOFTWARE:gunicorn/0.16.1
  INFO - gunicorn.socket:<socket fileno=12 sock=127.0.0.1:17010 peer=127.0.0.1:34707>
  INFO - wsgi.errors:<open file '<stderr>', mode 'w' at 0x7f6bd98b6270>
  INFO - wsgi.file_wrapper:gunicorn.http.wsgi.FileWrapper
  INFO - wsgi.input:<gunicorn.http.body.Body object at 0x5711910>
  INFO - wsgi.multiprocess:True
  INFO - wsgi.multithread:False
  INFO - wsgi.run_once:False
  INFO - wsgi.url_scheme:http
  INFO - wsgi.version:(1, 0)
  INFO - zato.http.response.headers:{}

.. _progguide-write-service-methods:

Service methods
~~~~~~~~~~~~~~~

.. _progguide-write-service-accept:

accept
``````

.. py:method:: accept()

One of the :doc:`hooks <./service-hooks>`. If a service returns False in this method, the processing stops. It's as though
the service has never been invoked, for instance, its usage count won't increase. Defaults to True and needs to be overriden
only if False should be returned.

Note that in accept the service has already full access to
:doc:`self.request <request-response>`,
:ref:`self.environ <progguide-write-service-environ>`
or
:ref:`self.wsgi_environ <progguide-write-service-wsgi_environ>`.
and these can be consulted in order to make a choice of returning True or False.

.. _progguide-write-service-after_add_to_store:

after_add_to_store
``````````````````

.. py:staticmethod:: after_add_to_store(logger)

Static method executed right after a service class has been added to the
service store. Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-after_cron_style_job:

after_cron_style_job
````````````````````

.. py:method:: after_cron_style_job()

Method executed right after a service has been invoked through a cron-style job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-after_handle:

after_handle
````````````

.. py:method:: after_handle()

Method executed right after a service's :ref:`handle <progguide-write-service-handle>`
method has returned. Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-after_interval_based_job:

after_interval_based_job
````````````````````````

.. py:method:: after_interval_based_job()

Method executed right after a service has been invoked through an interval-based job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-after_job:

after_job
`````````

.. py:method:: after_job()

Method executed right after a service has been invoked through a scheduler's
job, regardless of the latter's type.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-after_one_time_job:

after_one_time_job
``````````````````

.. py:method:: after_one_time_job()

Method executed right after a service has been invoked through a one-time job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_add_to_store:

before_add_to_store
```````````````````

.. py:staticmethod:: before_add_to_store(logger)

Static method executed right before a service class is added to the service store.
The service won't be deployed unless the method returns True.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_cron_style_job:

before_cron_style_job
`````````````````````

.. py:method:: before_cron_style_job()

Method executed right before a service is invoked through a cron-style job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_handle:

before_handle
`````````````

.. py:method:: before_handle()

Method executed right before a service's :ref:`handle <progguide-write-service-handle>`
is run. Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_interval_based_job:

before_interval_based_job
`````````````````````````

.. py:method:: before_interval_based_job()

Method executed right before a service is invoked through an interval-based job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_job:

before_job
``````````

.. py:method:: before_job()

Method executed right before a service is invoked through a scheduler's job,
regardless of the job's type.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-before_one_time_job:

before_one_time_job
```````````````````

.. py:method:: before_one_time_job()

Method executed right before a service is invoked through a one-time job.
Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-finalize_handle:

finalize_handle
```````````````

.. py:method:: finalize_handle()

Method executed after :ref:`handle <progguide-write-service-handle>` and other service
hooks have completed. Explained further in the :doc:`chapter on service hooks <./service-hooks>`.

.. _progguide-write-service-get_name:

get_name
````````

.. py:staticmethod:: get_name()

A static method that should be implemented to return
:ref:`service names <progguide-write-service-name>` other than what Zato
automatically generates.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My name is {}'.format(self.name))
          
      @staticmethod
      def get_name():
          return 'Something Else'

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  INFO - My name is Something Else

.. _progguide-write-service-handle:
  
handle
``````

.. py:method:: handle()

The only method a service must implement. The central place where most of the
message processing will take place. Each time a channel accepts a message,
a new instance of the service class will be created and its handle method will
be called. 

A service is fully initialized and ready to process the request at the time
handle is being invoked.

Request and response objects are documented in 
:doc:`their own chapter <./request-response>`.

.. _progguide-write-service-invoke:

invoke
``````
.. py:method:: invoke(name[, payload='', channel=CHANNEL.INVOKE, data_format=None, transport=None, serialize=False, as_bunch=False, environ=None])

  Synchronously invokes a service by its :ref:`name <progguide-write-service-name>`. The service
  is invoked in the same operating system's process and thread the current service
  is in. This is simply a standard invocation of another method so any exceptions
  raised in the service being invoked will propagate to the calling one.
  
  Other than consulting the 
  :ref:`channel <progguide-write-service-channel>`
  attribute, from the point of view of the service which is invoked, there is no way to
  discern that it's not being invoked through a regular channel created in the
  :doc:`web admin <../web-admin/intro>` or via :doc:`Zato's public API </public-api/intro>`.
  
  A `ZatoException <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_ will be raised if a service attempts to invoke itself.
  
  Visit :doc:`this chapter <./invoking-services>` for more information on how to invoke
  other services depending on the data format they expect.
  
  :param name: Name of the service to invoke.  The name may be followed by an
               :ref:`invocation target <admin-guide-config-server-invoke_target_patterns_allowed>`, a label
               assigned to one or more selected servers in a cluster ensuring in that way that only
               these targets will receive the request. The syntax for using targets is *service_name@target_name*.
               A `ZatoException <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
               will be raised if the server the service is invoked on does not accept the provided target.
  :type name: string
  
  :param payload: Request data to invoke a service with. This can be a regular
                  Python dictionary if the service which is invoked uses 
                  :doc:`SIO<./sio>`.
  
  :param channel: :ref:`Channel type <progguide-write-service-channel>` a service will think it's invoked over
  :type channel: `zato.common.CHANNEL <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
  
  :param data_format: :ref:`Data format <progguide-write-service-data_format>` a service expects, if any.
                      Can be skipped if the service uses :doc:`SIO<./sio>` and payload is a dictionary.
  :type data_format: `zato.common.DATA_FORMAT <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
  
  :param transport: Transport a service will think it's invoked with
  :type transport: `zato.common.TRANSPORT <https://github.com/zatosource/zato/blob/support/2.0/code/zato-common/src/zato/common/__init__.py>`_
  
  :param serialize: If the service which is invoked uses :doc:`SIO <./sio>`, 
                    whether its response should be serialized to data_format.
                    If False, a Python dictionary will be returned, unless as_bunch is True.
  :type serialize: bool
  
  :param as_bunch: If the service which is invoked uses :doc:`SIO <./sio>`, 
                    whether to return its response as a 
                    `Bunch <http://pypi.python.org/pypi/bunch>`_ object.
  :type as_bunch: bool

  :param environ: A dictionary of user-provided context that will be available in the receiving service's
                  :ref:`self.environ <progguide-write-service-environ>`. Must be JSON-serializable. Defaults to an
                  empty dict.
  :type environ: {}

  :rtype: Response the service being invoked produced
  
::

    from zato.server.service import Service

    class MyService(Service):
        def handle(self):
            payload = {'cluster_id': 1}
            response = self.invoke('zato.security.get-list', payload, as_bunch=True)
            for item in response.zato_security_get_list_response:
                self.logger.info(item.name)

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

    INFO - techacct-98014
    INFO - pubapi
    INFO - zato.ping.plain_http.basic_auth
    INFO - zato.ping.soap.basic_auth
    INFO - zato.ping.soap.wss.clear_text
    
.. _progguide-write-service-invoke_async:

invoke_async
````````````
.. py:method:: invoke_async(name[, payload='', channel=CHANNEL.INVOKE_ASYNC, data_format=None, transport=None, expiration=BROKER.DEFAULT_EXPIRATION, to_json_string=False, environ=None])

  Uses a service's :ref:`broker client <progguide-write-service-broker-client>`
  to execute another service asynchronously. It's not defined which server
  the service will be invoked on and its response is not available to the invoking
  service. Use the CID returned to correlate an asynchronous invocation with its
  response.
  
  A service should not invoke asynchronously itself, this would create an infinite loop.

  :param name: Name of the service to invoke. The name may be followed by an
               :ref:`invocation target <admin-guide-config-server-invoke_target_patterns_allowed>`, a label
               assigned to one or more selected servers in a cluster ensuring in that way that only
               these targets will receive the request. The syntax for using targets is *service_name@target_name*.
  :type name: string
  
  :param payload: Request data to invoke a service with. This can be a regular
                  Python dictionary if the service which is invoked uses 
                  :doc:`SIO<./sio>`.
                  
  :param channel: Same as for :ref:`invoke <progguide-write-service-invoke>`
  :param data_format: 〃
  :param transport: 〃
  
  :param expiration: After how many seconds the message should expire. Default is 15 seconds.
  :type expiration: int
                  
  :param to_json_string: Whether payload should be serialized to a JSON string. Should be
                         set to True if payload is a dictionary.
  :type to_json_string: bool

  :param environ: A dictionary of user-provided context that will be available in the receiving service's
                  :ref:`self.environ <progguide-write-service-environ>`. Must be JSON-serializable. Defaults to an
                  empty dict.
  :type environ: {}
  
  :rtype: :ref:`CID <progguide-write-service-cid>` the other service will be
          invoked with

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.invoke_async('zato.helpers.input-logger', 'My payload')

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

  INFO - {u'impl_name': u'zato.server.service.internal.helpers.InputLogger', 
    u'handle_return_time': datetime.datetime(2013, 2, 18, 20, 17, 1, 162872), 
    u'name': u'zato.helpers.input-logger', 
    u'cid': u'K241057352164304005274904154334359360347', 
    u'processing_time': 0, 
    u'invocation_time': datetime.datetime(2013, 2, 18, 20, 17, 1, 162850), 
    u'processing_time_raw': datetime.timedelta(0, 0, 22), 
    u'job_type': None, u'data_format': None, u'slow_threshold': 99999, 
    u'request.payload': u'"My payload"', u'wsgi_environ': None, 
    u'environ': {}, u'usage': 9, u'channel': u'publish'}
    
invoke_by_impl_name
```````````````````
.. py:method:: invoke(impl_name[, payload='', channel=None, data_format=None, transport=None, serialize=False, as_bunch=False])

Same as :ref:`invoke <progguide-write-service-invoke>` but using
a service's
:ref:`impl_name <progguide-write-service-impl_name>`
instead of its
:ref:`name <progguide-write-service-name>`.

.. _progguide-write-service-lock:

lock
````

Creates distributed locks - documented in :doc:`its own chapter <dist-locks>`.

.. _progguide-write-service-log_input:

log_input
`````````

.. py:method:: log_input([user_msg='', level=logging.INFO, suppress_keys=None])

  A helper method to write all the input data to server logs using a specified
  logging level which defaults to INFO. A user message of arbitrary data type
  can be provided and will be logged as well.
  
  :param user_msg: An additional user-provided message
  :param level: Logging level to use
  :param suppress_keys: A list of keys which shouldn't be logged
  :rtype: A dictionary of information which was logged
  
.. versionchanged:: 2.0
  
Note that below the service has been expoxed through a plain HTTP channel
at /service-api.my-service so it can be invoked from curl in order to show
input HTTP headers which log_input has access to.
  
::

    from zato.server.service import Service

    class MyService(Service):
        def handle(self):
            self.log_input("Let's find out what the input was")

::

  $ curl localhost:17010/service-api.my-service -d 'Hello'
  
::

  INFO - Let's find out what the input was {u'impl_name': u'req_resp.MyService', 
      u'name': u'req-resp.my-service', 
      u'cid': u'K003047659946670542740630609961875870964', 
      u'invocation_time': datetime.datetime(2013, 2, 19, 8, 16, 56, 253101), 
      u'job_type': None, u'data_format': None, 
      u'slow_threshold': 99999, u'request.payload': 'Hello', 
      u'wsgi_environ': {'SERVER_PROTOCOL': 'HTTP/1.1', 
        'SERVER_SOFTWARE': 'gunicorn/0.16.1', 'SCRIPT_NAME': '', 
        'wsgi.input': <gunicorn.http.body.Body object at 0x5489e50>, 
        'REQUEST_METHOD': 'GET', 'HTTP_HOST': 'localhost:17010', 
        'PATH_INFO': '/service-api.my-service', 'wsgi.multithread': False, 
        'QUERY_STRING': '', 'HTTP_ACCEPT': '*/*', 'HTTP_USER_AGENT': 
        'curl/7.22.0', 'wsgi.version': (1, 0), 'REMOTE_PORT': '38617', 
        'RAW_URI': '/service-api.my-service', 'REMOTE_ADDR': '127.0.0.1', 
        'wsgi.run_once': False, 
        'wsgi.errors': <open file '<stderr>', mode 'w' at 0x7f3c8f65d270>, 
        'wsgi.multiprocess': True, 'wsgi.url_scheme': 'http', 
        'gunicorn.socket': <socket at 0x525cb10 fileno=13 sock=127.0.0.1:17010 peer=127.0.0.1:38617>, 
        'SERVER_NAME': 'localhost', 'SERVER_PORT': '17010', 
      'wsgi.file_wrapper': <class gunicorn.http.wsgi.FileWrapper at 0x30a70b8>}, 
      u'environ': {}, u'usage': 4, u'channel': u'http-soap'}

.. _progguide-write-service-log_output:
      
log_output
``````````

.. py:method:: log_output([user_msg='', level=logging.INFO, suppress_keys=('wsgi_environ',)])

  Akin to :ref:`log_input <progguide-write-service-log_output>` but deals
  with the output data instead. Note that suppress_keys isn't None by default.

.. versionchanged:: 2.0
  
::

  # stdlib
  import logging

  # Zato
  from zato.server.service import Service

  class MyService(Service):

      def handle(self):
          self.response.payload = 'Greetings!'

      def finalize_handle(self):
          self.log_output('What was the output?', logging.DEBUG, 
              ['wsgi_environ', 'name', 'impl_name'])

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
::

  DEBUG - What was the output? {u'response.payload': 'Greetings!', 
      u'handle_return_time': datetime.datetime(2013, 2, 19, 8, 37, 36, 469453), 
      u'impl_name': u'(suppressed)', u'channel': u'http-soap',
      u'cid': u'K190324097308368662541391425956165369564', 
      u'processing_time': 0, u'name': u'(suppressed)',
      u'invocation_time': datetime.datetime(2013, 2, 19, 8, 37, 36, 469320), 
      u'processing_time_raw': datetime.timedelta(0, 0, 133), 
      u'job_type': None, u'data_format': None, u'slow_threshold': 99999, 
      u'environ': {}, u'usage': 8}


.. _progguide-write-service-translate:

translate
`````````
.. py:method:: translate(system1, key1, value1, system2, key2[, default=''])
          
   Uses :doc:`Redis <../architecture/redis>` to return a new 
   :doc:`translation <../web-admin/kvdb/data-dict>`
   from system1, key1 and value1 to system2 and key2.
   
   If there are two or more systems using different data dictionaries, it is desirable
   to be able to translate the dictionary values. 
   
   For instance, 
   if a CRM stores country codes as three-letter
   `ISO 3166-1 <https://en.wikipedia.org/wiki/ISO_3166-1>`_ codes whereas 
   a billing system a service connects to uses numeric codes, it can be said that,
   for Australia, there is a translation from CRM/COUNTRY_CODE/AUS
   to BILLING/COUNTRY_CODE with the result of 036. 
   
   The method can be used to translate values between such dictionaries.
   
::

    from zato.server.service import Service

    class MyService(Service):
        def handle(self):
            result = self.translate('CRM', 'COUNTRY_CODE', 'AUS', 'BILLING', 'COUNTRY_CODE')
            self.logger.info('Result is {}'.format(result))

::

  $ zato service invoke /opt/zato/server1 service-api.my-service
  
.. code-block:: text

    INFO - Result is 036

.. _progguide-write-service-broker-client:

Publish/subscribe broker client
-------------------------------

Each service can asynchronously publish messages to one or more services on
servers running in the same cluster the publishing service is in.

A message needs to be a dictionary of metadata whose only required key is 'action'
which must point to a Zato service you want to invoke using constants
from the 
`zato.common.broker_message <https://github.com/zatosource/zato/blob/feature/service-tests/code/zato-common/src/zato/common/broker_message.py>`_
module.

If you want to publish or send messages to all workers that contain your own services,
the action must be SERVICE.PUBLISH.value, this which will in turn publish the message to Zato's 
:doc:`zato.service.invoke </public-api/details/zato.service.invoke>` service 
which will next invoke the service of your choice by its 
:ref:`name <progguide-write-service-name>`.

.. note ::

  Publishing of messages to your own services is even simpler if you
  use the :ref:`invoke_async <progguide-write-service-invoke_async>`
  method.

.. _progguide-write-service-broker-client-publish:

Publishing a message to all servers (1:N)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All workers of all servers in a cluster will receive a message, including the one which
is publishing the message. 

It's possible that no subscriber will receive the message at all in a highly unlike
case when there's only one server with one worker in a cluster.
If the worker publishes a message - without the knowledge that it should be its
own sole recipient - and next goes down for any reason before the message
could be delivered - the message will be lost.

.. image:: /gfx/progguide/broker-client-publish.png
   :align: center
   
::

  from zato.common.broker_message import SERVICE
  from zato.common.util import new_cid
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          msg = {
              'action': SERVICE.PUBLISH.value,
              'service': 'zato.helpers.input-logger',
              'payload': 'My payload',
              'cid': new_cid()
          }
          self.broker_client.publish(msg)

::

  $ zato service invoke /opt/zato/server1 service-api.my-service

Note the data has been written out to logs twice because in this particular case
the cluster consisted of two servers, each running one worker.

Visit the :ref:`section on how to invoke only a single instance of a service <progguide-write-service-broker-client-invoke_async>`
if you don't want all of your services to receive the message.
  
.. code-block:: text

  INFO - {u'impl_name': u'zato.server.service.internal.helpers.InputLogger', 
    u'handle_return_time': datetime.datetime(2013, 2, 18, 20, 27, 17, 111426), 
    u'name': u'zato.helpers.input-logger', 
    u'cid': u'K243384249163255697882446959015306592567', u'processing_time': 0, 
    u'invocation_time': datetime.datetime(2013, 2, 18, 20, 27, 17, 111401), 
    u'processing_time_raw': datetime.timedelta(0, 0, 25), u'job_type': None, 
    u'data_format': None, u'slow_threshold': 99999, 
    u'request.payload': u'My payload', u'wsgi_environ': None, u'environ': {}, 
    u'usage': 14, u'channel': u'publish'}
    
  INFO - {u'impl_name': u'zato.server.service.internal.helpers.InputLogger', 
    u'handle_return_time': datetime.datetime(2013, 2, 18, 20, 27, 17, 111497), 
    u'name': u'zato.helpers.input-logger', 
    u'cid': u'K243384249163255697882446959015306592567', u'processing_time': 0, 
    u'invocation_time': datetime.datetime(2013, 2, 18, 20, 27, 17, 111478), 
    u'processing_time_raw': datetime.timedelta(0, 0, 19), u'job_type': None,
    u'data_format': None, u'slow_threshold': 99999, 
    u'request.payload': u'My payload', u'wsgi_environ': None, u'environ': {}, 
    u'usage': 13, u'channel': u'publish'}

.. _progguide-write-service-broker-client-invoke_async:

Sending a message to one of the servers (1:1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Exactly one worker among all servers in a cluster will receive a message, possibly 
the one which is publishing the message.

Redis will store the message for a configurable amount of time under a key
starting with 'zato:broker:to-parallel:any:' and then, if no worker picks it up,
it will expire. By default, expiration time is 15 seconds and can be specified when
sending the message.

Each service offers an :ref:`invoke_async <progguide-write-service-invoke_async>`
convenience wrapper to send a message to a single worker only.

.. image:: /gfx/progguide/broker-client-send.png
   :align: center
   
::

  from zato.common.broker_message import SERVICE
  from zato.common.util import new_cid
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          msg = {
              'action': SERVICE.PUBLISH.value,
              'service': 'zato.helpers.input-logger',
              'payload': 'My payload',
              'cid': new_cid()
          }
          self.broker_client.invoke_async(msg)

::

  $ zato service invoke /opt/zato/server1 service-api.my-servicePUBLISH

Note the data has been written out to logs once only even though the cluster
consisted of two servers, each running one worker.

You may also be interested in the :ref:`section on how to invoke all instances of a service <progguide-write-service-broker-client-publish>`
instead of a single one.
  
.. code-block:: text

  INFO - {u'impl_name': u'zato.server.service.internal.helpers.InputLogger', 
    u'handle_return_time': datetime.datetime(2013, 2, 18, 21, 42, 0, 783786), 
    u'name': u'zato.helpers.input-logger', 
    u'cid': u'K110292925198847762451855196826718257593', u'processing_time': 0,
    u'invocation_time': datetime.datetime(2013, 2, 18, 21, 42, 0, 783764), 
    u'processing_time_raw': datetime.timedelta(0, 0, 22), u'job_type': None, 
    u'data_format': None, u'slow_threshold': 99999, 
    u'request.payload': u'My payload', u'wsgi_environ': None, u'environ': {}, 
    u'usage': 20, u'channel': u'publish'}

.. note ::

  Don't forget about the :ref:`invoke_async <progguide-write-service-invoke_async>`
  method, which is a convenience wrapper for executing other services asynchronously.

